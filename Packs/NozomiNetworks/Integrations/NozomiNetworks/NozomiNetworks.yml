commonfields:
  id: Nozomi Networks
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: Nozomi Networks
display: Nozomi Networks
category: Network Security
image: data:image/png;base64,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
description: |-
  The Nozomi Networks Guardian platform is a hardware or virtual appliance that is used to monitor OT/IoT/IT networks. It combines asset discovery, network visualization, vulnerability assessment, risk monitoring and threat detection in a single solution.
    This integration is used to gather alerts and assets information from Nozomi.
configuration:
- display: Endpoint url
  name: endpoint
  defaultvalue: https://nozomi_instance.com
  type: 0
  required: true
  additionalinfo: Your Nozomi Networks appliance endpoint URL appliance
- display: Username
  name: credentials
  type: 9
  required: true
  additionalinfo: A user having APIs access privileges credentials.
- display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Get incidents from last
  name: fetchTime
  defaultvalue: 7 days
  type: 0
  required: false
  additionalinfo: 'Set the time frame to get incidents by. Default is 7 days. Other
    examples: 30 seconds, 1 minute, 4 hours, 2 days...'
- display: Get incidents from risk level
  name: riskFrom
  defaultvalue: "1"
  type: 15
  required: false
  options:
  - "1"
  - "2"
  - "3"
  - "4"
  - "5"
  - "6"
  - "7"
  - "8"
  - "9"
  - "10"
  additionalinfo: Will only fetch incident with a risk higher or equal to the selected
    value.
- display: Fetch also Nozomi incidents
  name: fecthAlsoIncidents
  type: 8
  required: false
  additionalinfo: In the Nozomi platform, alerts are single events and incidents are
    an aggregation of alerts. By default only alerts will be fetched by CORTEX XSOAR,
    however, if selected, incidents will also be fetched.
- display: Incidents Fetch Interval
  name: incidentFetchInterval
  defaultvalue: "1"
  type: 19
  required: false
- display: Incidents per run
  name: incidentPerRun
  defaultvalue: "20"
  type: 0
  required: false
  additionalinfo: Specifies the maximum number of incidents to retrieve during each
    fetch operation. This value determines the size of the result set fetched from
    the source system. Default is 20.
script:
  script: |-
    from datetime import timezone



    ''' IMPORTS '''

    import urllib3
    import json
    import requests

    urllib3.disable_warnings()


    class Client:
        def __init__(self, base_url=None, headers=None, verify=None, proxies=None, auth=None):
            self.base_url = base_url or demisto.params().get('endpoint')
            self.headers = headers or {'accept': "application/json"}
            self.verify = verify if verify is not None else not demisto.params().get('insecure', True)
            self.proxies = proxies if proxies is not None else demisto.params().get('proxy', False)
            self.auth = auth or (
                demisto.params().get("credentials", {}).get('identifier', ''),
                demisto.params().get("credentials", {}).get('password', '')
            )

        def _make_request(self, method, path, **kwargs):
            url = self.base_url + path
            demisto.info("Nozomi url " + url)
            response = requests.request(
                method=method,
                url=url,
                headers=self.headers,
                verify=self.verify,
                proxies=self.proxies,
                auth=self.auth,
                **kwargs
            )

            demisto.info("Nozomi status_code " + str(response.status_code))

            if response.status_code not in (200, 201, 202, 204):
                demisto.info(f"Nozomi Unexpected status code: {response.status_code}. Returning empty JSON.")
                return {"result": {}, "error": f"Unexpected status code: {response.status_code}"}

            demisto.info("Nozomi response.json(): " + str(response.json()))
            return response.json()

        def http_get_request(self, path):
            return self._make_request('GET', path)

        def http_post_request(self, path, data):
            return self._make_request('POST', path, json=data)


    ''' GLOBAL_VARIABLES '''
    INTEGRATION_NAME = 'Nozomi Networks'
    QUERY_PATH = '/api/open/query/do?query='
    QUERY_ALERTS_PATH = '/api/open/query/do?query=alerts'
    QUERY_ASSETS_PATH = '/api/open/query/do?query=assets | sort id'
    JOB_STATUS_MAX_RETRY = 5
    DEFAULT_HEAD_ALERTS = 20
    DEFAULT_HEAD_ASSETS = 50
    DEFAULT_HEAD_QUERY = 500
    MAX_ASSETS_FINDABLE_BY_A_COMMAND = 100
    DEFAULT_ASSETS_FINDABLE_BY_A_COMMAND = 50


    '''HELPER FUNCTIONS'''


    def get_client():
        return Client()


    def parse_incident(i):
        return {
            'name': f"{i['name']}_{i['id']}",
            'occurred': datetime.fromtimestamp(i['record_created_at'] / 1000, timezone.utc).isoformat(),
            'severity': parse_severity(i),
            'rawJSON': json.dumps(clean_null_terms(i))
        }


    def clean_null_terms(d):
        clean = {}
        for key, value in d.items():
            if isinstance(value, dict):
                nested = clean_null_terms(value)
                if len(nested.keys()) > 0:
                    clean[key] = nested
            elif value is not None:
                clean[key] = value
        return clean


    def parse_severity(item):
        result = int(float(item['risk']) / 2)
        if result < 1:
            return 1
        return result - 1 if result > 4 else result


    def ids_from_incidents(incidents_array):
        return [incident['id'] for incident in incidents_array]


    def better_than_time_filter(st):
        t = ''
        if st:
            t = f' | where record_created_at > {st}'
        return t


    def equal_than_time_filter(st):
        t = ''
        if st:
            t = f' | where record_created_at == {st}'
        return t


    def better_than_id_filter(id):
        res = ''
        if id:
            res = f' | where id > {id}'
        return res


    def start_time(last_run, fetch_time_from='7 days'):
        fetch_time_default, _ = parse_date_range(fetch_time_from, date_format='%Y-%m-%dT%H:%M:%SZ', to_timestamp=True)
        if has_last_run(last_run):
            time_from_last_run = f'{last_run.get("last_fetch", fetch_time_default)}'
            result = f'{fetch_time_default}' if time_from_last_run == '0' else f'{time_from_last_run}'
        else:
            result = f'{fetch_time_default}'
        return result


    def has_last_run(lr):
        return lr is not None and 'last_fetch' in lr


    def incidents_better_than_time(st, head, risk, also_n2os_incidents, client):
        return client.http_get_request(
            f'{QUERY_ALERTS_PATH} | sort record_created_at asc | sort id asc{better_than_time_filter(st)}'
            f'{risk_filter(risk)}{also_n2os_incidents_filter(also_n2os_incidents)} | head {head}'
        )['result']


    def incidents_equal_than_time(st, risk, also_n2os_incidents, client):
        return client.http_get_request(
            f'{QUERY_ALERTS_PATH} | sort record_created_at asc | sort id asc{equal_than_time_filter(st)}'
            f'{risk_filter(risk)}{also_n2os_incidents_filter(also_n2os_incidents)}'
        )['result']


    def also_n2os_incidents_filter(also_n2os_incidents):
        if also_n2os_incidents:
            return ''
        else:
            return ' | where is_incident == false'


    def risk_filter(risk):
        return f' | where risk >= {int(risk)}' if risk else ''


    def incidents_better_than_id(incidents_to_filter, the_id):
        return [incident for incident in incidents_to_filter if incident['id'] > the_id]


    def incidents_equal_time_better_id(st, last_id, risk, also_n2os_incidents, client):
        if last_id:
            return incidents_better_than_id(
                incidents_equal_than_time(st, risk, also_n2os_incidents, client),
                last_id)
        else:
            return []


    def incidents(st, last_id, last_run, risk, also_n2os_incidents, client, head=DEFAULT_HEAD_ALERTS):
        def get_incident_name(i):
            return i['name']

        ibtt = incidents_better_than_time(st, head, risk, also_n2os_incidents, client)

        lft = last_fetched_time(ibtt, last_run)
        lfid = last_fetched_id(ibtt, last_run)

        incidents_merged = incidents_equal_time_better_id(st, last_id, risk, also_n2os_incidents, client) + ibtt

        parsed_incidents = [parse_incident(i) for i in incidents_merged]
        parsed_incidents.sort(key=get_incident_name)

        return \
            parsed_incidents, \
            lft, \
            lfid


    def last_fetched_time(inc, last_run):
        return inc[-1]['record_created_at'] if len(inc) > 0 else last_run.get("last_fetch", 0)


    def last_fetched_id(inc, last_run):
        return inc[-1]['id'] if len(inc) > 0 else last_run.get("last_id", None)


    def last_asset_id(response):
        return response[-1]['id'] if len(response) > 0 else ''


    def ack_unack_alerts(ids, status, client):
        data = []
        for id in ids:
            data.append({'id': id, 'ack': status})
        response = client.http_post_request('/api/open/alerts/ack', {'data': data})

        return response.get("result", {}).get("id", None)


    def ack_alerts(ids, client):
        return ack_unack_alerts(ids, True, client)


    def nozomi_alerts_ids_from_demisto_incidents(demisto_incidents):
        return ids_from_incidents([json.loads(incident['rawJSON']) for incident in demisto_incidents])


    def close_alerts(args, close_action, client):
        readable_close_action = "closed_as_security" if close_action == "delete_rules" else "closed_as_change"
        extracted_ids = argToList(args.get('ids'))
        human_readable = f'Command changes the status of the following alerts: {extracted_ids} ' \
            f'passed as "{readable_close_action}" in Nozomi Networks platform.'

        client.http_post_request(
            '/api/open/alerts/close',
            {"ids": extracted_ids, "close_action": close_action})

        return {
            'readable_output': human_readable,
            'outputs_prefix': None,
            'outputs_key_field': None,
            'outputs': None
        }


    def has_last_id(lr):
        return lr is not None and 'last_id' in lr


    def get_last_id(last_run):
        result = None
        if has_last_id(last_run):
            result = f'{last_run.get("last_id", 0)}'
        return result


    def filter_from_args(args):
        if args and args.get('filter', '') != '':
            filter = args.get('filter', '')
            if '| where' in filter:
                return filter
            else:
                return f" | where {filter}"
        else:
            return ''


    def assets_limit_from_args(args):
        if args:
            limit = int(args.get('limit', DEFAULT_ASSETS_FINDABLE_BY_A_COMMAND))
            if limit > MAX_ASSETS_FINDABLE_BY_A_COMMAND:
                return MAX_ASSETS_FINDABLE_BY_A_COMMAND
            else:
                return limit
        else:
            return DEFAULT_ASSETS_FINDABLE_BY_A_COMMAND


    def nodes_confirmed_filter(only_nodes_confirmed):
        if only_nodes_confirmed and only_nodes_confirmed == 'True':
            return ' | where mac_address:info.likelihood_level == confirmed'
        else:
            return ''


    def humanize_api_error(error):
        if '401' in error:
            return 'Authentication error, check your username and password'
        else:
            return error


    ''' MAIN_FUNCTION '''


    def fetch_incidents(
            client,
            st=None,
            last_run=None,
            last_id=None,
            risk=None,
            fetch_also_n2os_incidents=None,
            test_mode=False
    ):
        st = st or start_time(demisto.getLastRun(), demisto.params().get('fetchTime', '7 days').strip())
        last_run = last_run or demisto.getLastRun()
        last_id = last_id or get_last_id(demisto.getLastRun())
        risk = risk or demisto.params().get('riskFrom', None)
        fetch_also_n2os_incidents = fetch_also_n2os_incidents or demisto.params().get('fecthAlsoIncidents', False)

        demisto_incidents, last_fetch, last_id_returned = \
            incidents(st, last_id, last_run, risk, fetch_also_n2os_incidents, client)

        if not test_mode:
            demisto.setLastRun({'last_fetch': last_fetch, 'last_id': last_id_returned})
            ack_alerts(nozomi_alerts_ids_from_demisto_incidents(demisto_incidents), client)
            demisto.incidents(demisto_incidents)

        return demisto_incidents, last_fetch


    def is_alive(client):
        error = None
        try:
            client.http_get_request(f'{QUERY_ALERTS_PATH} | count')
        except Exception as e:
            error = e.args[0]

        return humanize_api_error(error) if error else 'ok'


    def close_incidents_as_change(args, client):
        return close_alerts(args, 'learn_rules', client)


    def close_incidents_as_security(args, client):
        return close_alerts(args, 'delete_rules', client)


    def query(args, client):
        title = f'{INTEGRATION_NAME} - Results for Query'
        response = client.http_get_request(
            f'{QUERY_PATH}{args.get("query", "")} | head {DEFAULT_HEAD_QUERY}')

        if 'error' in response and response['error']:
            return {
                'outputs_key_field': None,
                'outputs': None,
                'outputs_prefix': None,
                'readable_output': response['error']
            }

        result = response['result']
        human_readable = tableToMarkdown(t=result, name=title, removeNull=True)

        return {
            'outputs': result,
            'outputs_prefix': 'Nozomi.Query.Result',
            'outputs_key_field': '',
            'readable_output': human_readable
        }


    def find_assets(args, client, head=DEFAULT_HEAD_ASSETS):
        title = f'{INTEGRATION_NAME} - Results for Find Assets'
        limit = assets_limit_from_args(args)
        result = []  # type: List[dict]
        last_id = None
        are_there_assets_to_request = True

        if head > limit:
            head = limit

        while limit > len(result) and are_there_assets_to_request:
            raw_response = client.http_get_request(
                f'{QUERY_ASSETS_PATH}{filter_from_args(args)}{better_than_id_filter(last_id)} | head {head}')
            last_id = last_asset_id(raw_response['result'])
            are_there_assets_to_request = head == len(raw_response['result'])
            result = result + raw_response['result']

        if not result:
            return {
                'outputs': [],
                'outputs_prefix': 'Nozomi.Asset',
                'outputs_key_field': 'id',
                'readable_output': f'{INTEGRATION_NAME} - No assets found'
            }

        human_readable = tableToMarkdown(
            t=result,
            name=title,
            removeNull=True,
            headers=['id', 'name', 'ip', 'mac_address', 'level firmware_version', 'os vendor', 'type']
        )
        return {
            'outputs': result,
            'outputs_prefix': 'Nozomi.Asset',
            'outputs_key_field': 'id',
            'readable_output': human_readable
        }


    def find_ip_by_mac(args, client):
        mac = args.get("mac", "")
        only_nodes_confirmed = args.get("only_nodes_confirmed", True)
        result_error = False
        result = {}  # type: Dict

        response = client.http_get_request(
            f'{QUERY_PATH}nodes | select ip mac_address | where mac_address == {mac}{nodes_confirmed_filter(only_nodes_confirmed)}')

        if len(response["result"]) == 0:
            human_readable = f'{INTEGRATION_NAME} - No IP results were found for mac address: {mac}'
            result_error = True
            prefix = None
        else:
            ips = [node['ip'] for node in response["result"]]
            human_readable = f'{INTEGRATION_NAME} - Results for the Ip from Mac Search is {ips}'
            result = {
                'ips': ips,
                'mac': mac
            }
            prefix = 'Nozomi.IpByMac'

        return {
            'outputs': None if result_error else result,
            'outputs_prefix': prefix,
            'outputs_key_field': None,
            'readable_output': human_readable
        }


    ''' EXECUTION '''


    def main():
        try:
            client = get_client()
            if demisto.command() == 'fetch-incidents':
                fetch_incidents(client)
            elif demisto.command() == 'test-module':
                if demisto.params().get('isFetch'):
                    fetch_incidents(client, test_mode=True)
                    demisto.results('ok')
                else:
                    demisto.results(is_alive(client))
            elif demisto.command() == 'nozomi-close-incidents-as-change':
                return_results(CommandResults(**close_incidents_as_change(demisto.args(), client)))
            elif demisto.command() == 'nozomi-close-incidents-as-security':
                return_results(CommandResults(**close_incidents_as_security(demisto.args(), client)))
            elif demisto.command() == 'nozomi-find-assets':
                return_results(CommandResults(**find_assets(demisto.args(), client)))
            elif demisto.command() == 'nozomi-query':
                return_results(CommandResults(**query(demisto.args(), client)))
            elif demisto.command() == 'nozomi-find-ip-by-mac':
                return_results(CommandResults(**find_ip_by_mac(demisto.args(), client)))
        except Exception as e:
            error_message = f"Nozomi Error of type {type(e).__name__} occurred: {str(e)}"
            demisto.error(error_message)
            return_error(error_message)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  type: python
  commands:
  - name: nozomi-find-assets
    arguments:
    - name: filter
      description: You can add a filter to get exactly the assets you want, to know
        how to filter assets using the Nozomi query language take a look at the n2os
        user documentation. For example 'where ip match 10.0.1.10', 'where vendor
        ==  Selta Telematica S.p.a'.
    - name: limit
      description: Maximun number of assets get from Nozomi, can't be bigger than
        100.
      defaultValue: "50"
    outputs:
    - contextPath: Nozomi.Asset.id
      description: uniq id of an asset.
      type: String
    - contextPath: Nozomi.Asset.level
      description: network layer.
      type: Number
    - contextPath: Nozomi.Asset.capture_device
      description: source from which the asset was captured.
      type: String
    - contextPath: Nozomi.Asset.ip
      description: array of asset ip.
      type: Unknown
    - contextPath: Nozomi.Asset.mac_address
      description: array of asset mac address.
      type: Unknown
    - contextPath: Nozomi.asset.mac_vendor
      description: array of mac vendor.
      type: Unknown
    - contextPath: os
      description: operating system.
      type: String
    - contextPath: vendor
      description: asset vendor.
      type: String
    - contextPath: Nozomi.Asset.firmware_version
      description: firmaware version.
      type: String
    - contextPath: serial_number
      description: serial number.
      type: String
    - contextPath: product_name
      description: product name.
      type: String
    - contextPath: type
      description: asset type as 'OT_device'.
      type: String
    - contextPath: protocols
      description: array of asset protocols.
      type: Unknown
    description: This command permits you to get some assets from Nozomi, you can
      use the query filter to to refine your search. With the limits you can decide
      the max number of assets you can retrieve from Nozomi, the limit can't be bigger
      than 100.
  - name: nozomi-close-incidents-as-security
    arguments:
    - name: ids
      description: List of IDs to close as security.
      isArray: true
    description: Close incidents as security.
  - name: nozomi-close-incidents-as-change
    arguments:
    - name: ids
      description: List of IDs to close as change.
      isArray: true
    description: Close incidents as change.
  - name: nozomi-query
    arguments:
    - name: query
      required: true
      description: A valid query, to learn how to create a Nozomi query you can take
        a look into the Nozomi Networks user documentation.
      defaultValue: alerts | count
    outputs:
    - contextPath: Nozomi.Query.Result
      description: An array of items.
      type: Unknown
    description: |-
      Can execute a nozomi query to get all the information you want.
      A query can be something like that: "alerts | select id name status ack | where status == open"
      Take a look to n2os manual to know how to do a query.
  - name: nozomi-find-ip-by-mac
    arguments:
    - name: mac
      required: true
      description: a mac address.
      defaultValue: ''''''
    - name: only_nodes_confirmed
      required: true
      default: true
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: This argument permit you to return only the nodes IPs from a mac
        address of nodes having the status to "confirmed". Default value is True.
      defaultValue: "True"
    outputs:
    - contextPath: Nozomi.IpByMac.ips
      description: Array of ips found for the mac address passed, empty if not found.
      type: Unknown
    - contextPath: Nozomi.IpByMac.mac
      description: Mac found the ips.
      type: String
    description: Find a node ip from a mac address.
  dockerimage: demisto/python3:3.10.14.92207
  isfetch: true
  runonce: false
  subtype: python3
